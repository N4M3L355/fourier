<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Fourier</title>
    <script src="p5.min.js"></script>
    <script src="p5.sound.min.js"></script>
    <script src="bundle.js"></script>
    <style>
        body {
            background-color: black;
            color: lightgrey;
        }

        #out {
            position: absolute;
            text-align: right;
            width: 98%;
        }
    </style>
</head>
<body>
<p id="out"></p>
<script>

    let out = (where => (...what) => {
        where.innerHTML = what;
    })(document.getElementById("out"));

    let sum = (...a) => a.reduce((a, b) => a + b);
    let mean = (...a) => sum(...a) / a.length;
	let product = (...a) => a.reduce((a,b) => a*b);
	let geoMean = (...a) => Math.abs(product(...a))**(1/a.length);

    let paintPixel = (x, y, r, g, b, a) => {      //needs to have pixels loaded
        let d = pixelDensity();
        for (let i = 0; i < d; i++) {
            for (let j = 0; j < d; j++) {
                // loop over
                idx = 4 * ((y * d + j) * width * d + (x * d + i));
                pixels[idx] = r;
                pixels[idx + 1] = g;
                pixels[idx + 2] = b;
                pixels[idx + 3] = a;
            }
        }
    };
    let getPixel = (x, y) => {      //needs to have pixels loaded
        let d = pixelDensity();
        let off = (y * width + x) * d * 4;
        return [pixels[off], pixels[off + 1], pixels[off + 2], pixels[off + 3]];
    };

    function lagrangeQuadraticInterpolation(points, x) {
        if (!points[0] || !points[1] || !points[2]) return 0;
        let x_1 = points[0][0], y_1 = points[0][1];
        let x_2 = points[1][0], y_2 = points[1][1];
        let x_3 = points[2][0], y_3 = points[2][1];
        return y_1 * (x - x_2) * (x - x_3) / ((x_1 - x_2) * (x_1 - x_3))
            + y_2 * (x - x_1) * (x - x_3) / ((x_2 - x_1) * (x_2 - x_3))
            + y_3 * (x - x_1) * (x - x_2) / ((x_3 - x_1) * (x_3 - x_2))
    }

    let getNearestIndexes = (array, where, n) => {      //optimalize
        return array.slice(Math.max(Math.round(where - n / 2), 0), Math.round(where + n / 2))
    };


    function SlidingArray(length, item = 0) {
        this.length = length; //percussion averages memory length
        this.datapoints = Array(this.length).fill(item);
        this.index = 0;
        this.append = (x) => {
            this.datapoints[this.index] = x;
            this.index = (this.index + 1) % this.length;
        };
        this.get = () => [...this.datapoints.slice(this.index, this.length), ...this.datapoints.slice(0, this.index)];
    }

	function Spectrum(smoothing, fourierPoints, pointsToAnalyze, pointsToShow) {
		this.smoothing = smoothing;		//makes sense from 3/4 to 23/24
        this.fourierPoints = fourierPoints;   //this needs to be 2^n
        this.samplingFrequency = 44100;         //this needs to be same as in operating system
        this.pointsToAnalyze = pointsToAnalyze;
        this.pointsToShow = pointsToShow;
        this.indexToHz = i => i * (this.samplingFrequency / 2) / this.fourierPoints;
        this.hzToIndex = hz => hz * this.fourierPoints / (this.samplingFrequency / 2);
        this.datapoints = [];
        this.tonalAmps = [];
        this.tonalSums = [];
        this.base = 110;
        this.step = 2 ** (1 / 12);
        this.octaves = 6;
        this.framesToAnalyze = 3 * 60;
		this.history = {
			kickAvgs: new SlidingArray(this.framesToAnalyze), //kick averages
            hihatAvgs: new SlidingArray(this.framesToAnalyze), //hihat averages
            entireVolumes: new SlidingArray(this.framesToAnalyze),
            tonalAmps: new SlidingArray(this.framesToAnalyze, [0]),
            tonalSums: new SlidingArray(this.framesToAnalyze,[0]),
			processedTonalSums: Array(12).fill().map(() => new SlidingArray(this.framesToAnalyze, [0,0]))	//this is array itself!
        };
        this.getNearestPoints = (where, n) => getNearestIndexes(this.datapoints.map((x, i) => [i, x]), where, n);
        this.getInterpolatedAmp = (hz) => {
            return lagrangeQuadraticInterpolation(this.getNearestPoints(this.hzToIndex(hz), 3), this.hzToIndex(hz))
        }


    }


    //TODO: masking, fft na rytmus, derivácia nôt, time eventing

    let mic, fft;
    let spectrum = new Spectrum(28/32, 2048, 1536, 1536);
    let myScale = ["A", "A#", "H", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"];
    let myScaleHues = [90, 300, 150, 0, 210, 60, 270, 120, 330, 180, 30, 240];
    let tonalFrequencies = [];
    for (let i = 1; i < 2 ** spectrum.octaves; i *= spectrum.step) tonalFrequencies.push(spectrum.base * i);
    horizontalScaling = 3;

    function setup() {
        background(0);
        createCanvas(spectrum.pointsToShow * horizontalScaling, window.innerHeight * 2);
        noFill();
        mic = new p5.AudioIn();
        mic.start();
        fft = new p5.FFT(spectrum.smoothing, spectrum.fourierPoints);
        fft.setInput(mic);
        stroke(255, 204, 0);
    }

    function draw() {
        background(0);
        noFill();
        spectrum.datapoints = fft.analyze().slice(0, spectrum.pointsToShow);       //slice to show only 0 - 10025 Hz
        spectrum.dataTuples = spectrum.datapoints.slice(0, spectrum.pointsToAnalyze).map((x, i) => [i, x]);  //slice to analyze only 0 - 5012.5 Hz, first is index, second amplitude

        stroke(255, 255, 255);
        strokeWeight(1);
        beginShape();
        for (let i = 0; i < spectrum.datapoints.length; i++) {    //draw spectrum
            vertex(horizontalScaling * i, map(spectrum.datapoints[i], 0, 255, height / 2, 0));
        }
        endShape();

        beginShape();
        //stroke(255, 204, 0);
        //strokeWeight(10);
        let SpectrumTuplesSortedByAmp = spectrum.dataTuples.sort((a, b) => a[1] - b[1]);
        //let SpectrumTuplesSortedByHz = SpectrumTuplesSortedByAmp.slice(0, spectrum.pointsToAnalyze).sort((a, b) => a[0] - b[0]);
        //let SpectrumTuplesSortedByHzFiltered = SpectrumTuplesSortedByHz.filter((x, i, a) => x[1] !== 0 && x[1] === Math.max(...(getNearestIndexes(a,i,5).map(y => y[1]))));
        //out(SpectrumTuplesSortedByHzFiltered.map(x => `${Math.floor(spectrum.indexToHz(x[0]))} Hz - ${x[1]}`).join("<br>"));
        /*for (let p of SpectrumTuplesSortedByHzFiltered.map(x => x[0])) {    //spikes
                if (spectrum.indexToHz(p) > 85 && spectrum.indexToHz(p) < 800) stroke(255, 0, 0);
                else stroke(255, 204, 0);
                point(horizontalScaling * p, map(spectrum.datapoints[p], 0, 255, height, 0));
        }*/
        stroke(255, 0, 255);
        strokeWeight(1);
        for (let i = 0; i < 12; i++) {        //octave bands, tone A
            line(spectrum.hzToIndex(110 * 2 ** i) * horizontalScaling, 0, spectrum.hzToIndex(spectrum.base * 2 ** i) * horizontalScaling, window.innerHeight / 2);
        }
        strokeWeight(15);
        colorMode(HSB);
        spectrum.tonalAmps = tonalFrequencies.map((x, i, a) => [x, spectrum.getInterpolatedAmp(x)]);      //interpolated tone amplitudes
        spectrum.tonalSums = Array(12).fill(0);
        spectrum.tonalAmps.forEach((x, i, a) => {     //draw interpolated tone amplitudes
            stroke(myScaleHues[i % 12], 100, x[1]);
            point(horizontalScaling * spectrum.hzToIndex(x[0]), map(x[1], 0, 255, window.innerHeight / 2, 0));
		});
		spectrum.tonalAmps.forEach((x, i, a) => {
			sortedE = a.slice(Math.max(i - 6, 0), i + 6).sort((a, b) => a[1] - b[1]);
			spectrum.tonalSums[i % 12] += (x[1] - sortedE[Math.floor(sortedE.length / 2)][1]) / 4;	//*((i-i%12)/12+1);
		});
        spectrum.history.tonalSums.append(spectrum.tonalSums);
		spectrum.tonalSums = ((avg, min) => spectrum.tonalSums.map((x, i, a) => Math.min(map(x, min, avg, 0, 0.5), 1)))(mean(...spectrum.tonalSums), Math.min(...spectrum.tonalSums));    //normalization
		out(spectrum.tonalSums.join("<br>"));
		spectrum.tonalSums.forEach((x, i, a) => {
			stroke(myScaleHues[i % 12], 100, 100);
			point(window.innerWidth - 32 - (12 - i) * 32, window.innerHeight - 128 - (x) * 256);
		});
		spectrum.history.tonalAmps.append(spectrum.tonalAmps);

        strokeWeight(1);
        myScale.forEach((x, i, a) => {
            stroke(myScaleHues[i % 12], 100, 100);
            text(x, window.innerWidth - 32 - (12 - i) * 32, window.innerHeight - 104);
        });


        colorMode(RGB);

        strokeWeight(1);
        stroke(255, 204, 0);

        let kickAvg = mean(...spectrum.datapoints.slice(spectrum.hzToIndex(0), spectrum.hzToIndex(80)));
        spectrum.history.kickAvgs.append(kickAvg);

        line(horizontalScaling * spectrum.hzToIndex(0),
            map(kickAvg, 0, 255, window.innerHeight / 2, 0),
            horizontalScaling * spectrum.hzToIndex(80),
            map(kickAvg, 0, 255, window.innerHeight / 2, 0)
        );


        beginShape();
        spectrum.history.kickAvgs.get().map((x, i, a) => {
            vertex(horizontalScaling * i, map(x, 0, 255, window.innerHeight, window.innerHeight / 2));
            if (x !== 0 && x === Math.max(...a.slice(i - 12, i + 12))) {
                strokeWeight(10);
                point(horizontalScaling * i, map(x, 0, 255, window.innerHeight, window.innerHeight / 2));
                strokeWeight(1);
            }
        });
        endShape();

        stroke(128, 128, 128);
        let hihatAvgs = mean(...spectrum.datapoints.slice(spectrum.hzToIndex(4000), spectrum.hzToIndex(8000)));
        spectrum.history.hihatAvgs.append(hihatAvgs);

        line(horizontalScaling * spectrum.hzToIndex(4000),
            map(hihatAvgs, 0, 255, window.innerHeight / 2, 0),
            horizontalScaling * spectrum.hzToIndex(8000),
            map(hihatAvgs, 0, 255, window.innerHeight / 2, 0)
        );

        beginShape();
        spectrum.history.hihatAvgs.get().forEach((x, i, a) => {
            vertex(horizontalScaling * i, map(x, 0, 255, window.innerHeight, window.innerHeight / 2));
            if (x !== 0 && x === Math.max(...a.slice(i - 12, i + 12))) {
                strokeWeight(5);
                point(horizontalScaling * i, map(x, 0, 255, window.innerHeight, window.innerHeight / 2));
                strokeWeight(1);
            }
        });

        endShape();

		stroke(128, 0,0);
		let volumeAmpsAvg = mean(...SpectrumTuplesSortedByAmp.slice(-64).map(x => x[1]));
		spectrum.history.entireVolumes.append(volumeAmpsAvg);
		beginShape();
		stroke(128, 128, 128);
		spectrum.history.entireVolumes.get().forEach((x, i, a) => {
			colorMode(RGB);
			vertex(horizontalScaling * i, map(x, 0, 255, height, height / 2));
			if (x !== 0 && x === Math.max(...a.slice(i - 12, i + 12))) {
				strokeWeight(5);
				point(horizontalScaling * i, map(x, 0, 255, height, height / 2));
				strokeWeight(1);
			}
		});

		endShape();

        /*let exaggeratedTonalSums =spectrum.tonalSums.map(x=>x**6);
        let entireSum = sum(...exaggeratedTonalSums);
        let actualSum = 0, part;
        let sortedTonalSums = exaggeratedTonalSums.map((x,i)=>[i,x]);//.sort((a,b) => a[1]-b[1]);
        sortedTonalSums.forEach((tonalSum,i)=>{
            part=tonalSum[1]/entireSum;
            spectrum.history.processedTonalSums[tonalSum[0]].append([map(actualSum,0,1,height,height/2),map(actualSum+part,0,1,height,height/2)]);
            actualSum+=part;
        });/**/

        colorMode(HSB);
        /*spectrum.history.processedTonalSums.forEach((history,tone) =>{
            stroke(myScaleHues[tone],100,100);
            history.get().forEach((x,i)=>{
                line(horizontalScaling*i,x[0],horizontalScaling*i,x[1]);
			})
		});*/
		colorMode(RGB);
	}


</script>

</body>
</html>